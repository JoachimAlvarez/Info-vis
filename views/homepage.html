<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>InfoVis</title>
  </meta>
</head>
<style>
  body {
      font-family: Sans-serif;
      font-size: 0.75em;
  }
  .slice {
      cursor: pointer;
  }
  .slice .main-arc {
      stroke: #fff;
      stroke-width: 1px;
  }
  .slice .hidden-arc {
      fill: none;
  }
  .slice text {
      pointer-events: none;
      dominant-baseline: middle;
      text-anchor: middle;
  }
  .breadcrumbs {
    border: 1px;
  }
  .breadcrumb {
    font-weight: bold;
    font-size: 2em;
  }
  h1 {
    font-weight: bold;
    text-align: center;
    font-size: 3.5em;
  }
  h2 {
    vertical-align: top;
    font-weight: bold;
    text-align: center;
    font-size: 2em;
  }
  p {
    text-align: left;
  }
</style>
<body>
<div><h1>Information Visualisation</h1></div>
<div id="sequence" class="breadcrumbs" style="width: 100%;height: 30px;float: top;"></div>
<div style="height: 80%;float: bottom;">
  <div id="svg-div" style="width: 70%;float: left;"></div>
  <div id="sidebar" style="width: 30%;float: right;">
    <div id="item_info" style="float:top">
      <h2 id="item_name"></h2>
      <div id="info"></div>
    </div>
    <div id="legenda" style="float: right;float:bottom;position:fixed">
      <h2 id="d"></h2>
    </div>
  </div>
</div>
</body>
<script src="libs/jquery/dist/jquery.min.js"></script>
<script src="libs/d3/d3.js"></script>
<script type="text/javascript">

// ----------------------------------
// Color Blindness

// Saturation (low->high: high->low scores)
// white as neutral

const COLOR_BLIND_GRADE_COLORS = []; // ? -> yellow -> white -> ??? -> licht brown
const NORMAL_GRADE_COLORS = []; // green -> yellow -> blue/white -> purple -> red

const COLORS = []; // Light-saturation colors
const COLOR_BLIND_COLORS = [];

const colors = NORMAL_GRADE_COLORS;

const DEPTH = 4;

// not, part, full
let COLOR_BLIND = false;

function setColorBlind(colorblind, grades) {
  COLOR_BLIND = colorblind;
  if (grades) {
    (colorblind) ? (colors = COLOR_BLIND_GRADE_COLORS) : (colors = NORMAL_GRADE_COLORS);
  }
  else {

  }
}

function getColor(grade=false) {

}


// -----------------------------------
// Init constants and helper functions

const formatNumber = d3.format(',d');
const width = $('#svg-div').width();// window.innerWidth;
const height = (window.innerHeight *80 /100); //$('#svg-div').height();//;
const radius = (Math.min(width, height) / 2) - 5;
const x = d3.scaleLinear().range([0, 2 * Math.PI]).clamp(true);
const y = d3.scaleSqrt().range([radius*.1, radius]);
const color = d3.scaleOrdinal(d3.schemeCategory10);
const partition = d3.partition();

const arc = d3.arc()
    .startAngle(d => x(d.x0))
    .endAngle(d => x(d.x1))
    .innerRadius(d => Math.max(0, y(d.y0)))
    .outerRadius(d => Math.max(0, y(d.y1)))

const middleArcLine = d => {
    const halfPi = Math.PI/2;
    const angles = [x(d.x0) - halfPi, x(d.x1) - halfPi];
    const r = Math.max(0, (y(d.y0) + y(d.y1)) / 2);
    const middleAngle = (angles[1] + angles[0]) / 2;
    const invertDirection = middleAngle > 0 && middleAngle < Math.PI; // On lower quadrants write text ccw
    if (invertDirection) { angles.reverse(); }
    const path = d3.path();
    path.arc(0, 0, r, angles[0], angles[1], invertDirection);
    return path.toString();
};

const textFits = d => {
    const CHAR_SPACE = 6;
    const deltaAngle = x(d.x1) - x(d.x0);
    const r = Math.max(0, (y(d.y0) + y(d.y1) +40) / 2); // Changed
    const perimeter = r * deltaAngle;
    return d.data.name.length * CHAR_SPACE < perimeter;
};


// ---------------------------------------------------------------------
// This is the Visualisation

var svg = d3.select("#svg-div").append("svg:svg")
    .attr("width", width)
    .attr("height", height)
    .append("svg:g")
    .attr("id", "container")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
    .on('click', clickOn);

d3.select("#container").on("mouseleave", d => mouseLeave(d, true));

// ---------------------------------------------------------------------
// Side Information

var Depths = { 0: 'Foods', 1: 'Food Groups', 2: 'Food Subgroups', 3: 'Food'}

function showFoodInformation(d) {
  const name_scientific = d.data.name_scientific;
  const description = d.data.description || "Description not available";
  const parent_name = d.parent.data.name;

  var div = document.createElement('div');
  let html = '';
  if (name_scientific) {
    html += '<p style="text-align: center;"><b>Scientific Name:</b> '+name_scientific+'</p>'
  }
  html += '<p><b>Parent Group:</b> '+parent_name+'</p>';
  html += '<p>'+description+'</p>';
  div.innerHTML = html;

  document.getElementById('info').appendChild(div);
}

function showDishInformation(d) {

}

function getGroups(d) {
  var group_children = d.data.children;
  var groupNames = Array.from(group_children(group_children, child => { return child.data.name}));



  
}

function showGroupInformation(d) {
  var info_div = $('#info');
  var group_name = d.data.name;
  var group_parent = group_name || d.parent.data.name;
  var grade = d.data.grade;
  var group_children = d.data.children || ""; // Bug that appears until foods are added to the system
  var groupNames = Array.from(group_children, child => { return child.name});

  var div = document.createElement('div');
  let html = '<p><b>Number of Subgroups:</b> '+group_children.length+'</p>';
  html += '<p><b>Subgroups:</b> '+groupNames+'</p>';
  if (grade) {
    html += '<p><b>Grade:</b> '+grade+'</p>';
  }
  div.innerHTML = html;


    
  document.getElementById('info').appendChild(div);
}

function clearInformation(d) {
  var info_div = $('#info');
  let name = $('#item_name');
  
  if (d.depth === DEPTH) {
    name[0].innerText = "";
  }

  info_div.empty();
}

function updateInformation(d) {
  clearInformation(d);

  const name = d.data.name;
  let name_div = $('#item_name');
  name_div[0].innerText = name;

  switch(d.depth) {
    case 0: showGroupInformation(d); 
      break;
    case 1: showGroupInformation(d); 
      break;
    case 2: showGroupInformation(d); 
      break;
    case 3: showFoodInformation(d); 
      break;
    case 4: showDishInformation(d); 
      break;
    default: console.log("Error: unhandled depth", d);
  }
}

// ---------------------------------------------------------------------
// Clickable Breadcrumbs

function clearBreadCrumbs() {
  d3.select('.breadcrumbs').selectAll('.breadcrumb').remove();
};

function updateBreadcrumbs(d) {
    clearBreadCrumbs();

    const crumbContainer = d3.select('.breadcrumbs');
    const anc = getAncestors(d);

    // Add First: 'Foods'
    crumbContainer.append('span')
        .classed('breadcrumb', true)
        .text(anc[0].data.name)
        .on("click", (_, a ,f) => { clickOn(anc[0]) });

    // add rest
    for (i = 1; i < anc.length; i++) {
      const n = anc[i];
      crumbContainer.append('span')
        .classed('breadcrumb', true)
        .text("  >  "+n.data.name)
        .on("click", (_, a ,f) => { clickOn(n) });
    } 
}

function getAncestors(node) {
  var path = [];
  var current = node;
  while (current.parent) {
    path.push(current);
    current = current.parent;
  }
  path.push(current)
  path.reverse();
  return path;
}

// ---------------------------------------------------------------------
// Opacity

function setOpacity(d, op) {
  var sequenceArray = getAncestors(d);
  d3.selectAll("path").style("opacity", op);
  svg.selectAll("path")
      .filter(node => { return (sequenceArray.indexOf(node) >= 0)})
      .style("opacity", 1);

}

// ---------------------------------------------------------------------
// UI listeners

function mouseOver(d) {
  updateBreadcrumbs(d);
  updateInformation(d);
  setOpacity(d, 0.3);
}

function mouseLeave(d, segment=false) { 

}

function clickOn(d = { x0: 0, x1: 1, y0: 0, y1: 1 }) {
    const transition = svg.transition()
        .duration(750)
        .tween('scale', () => {
            const xd = d3.interpolate(x.domain(), [d.x0, d.x1]);
            const yd = d3.interpolate(y.domain(), [d.y0, 1]);
            return t => { x.domain(xd(t)); y.domain(yd(t)); };
        });
    transition.selectAll('path.main-arc').attrTween('d', d => () => arc(d));
    transition.selectAll('path.hidden-arc').attrTween('d', d => () => middleArcLine(d));
    transition.selectAll('text').attrTween('display', d => () => textFits(d) ? null : 'none');
}

// ----------------------------------------------------------------------
// Sunburst

function VisualiseData(data) {
  const root = d3.hierarchy(data)
      .sum(d => d.size);

  const slice = svg.selectAll('g.slice')
      .data(partition(root).descendants());
  slice.exit().remove();

  const newSlice = slice.enter()
      .append('g').attr('class', 'slice')
      .on('mouseover', mouseOver)
      .on('click', d => { d3.event.stopPropagation(); clickOn(d) });

  newSlice.append('title')
      .text(d => d.data.name);
  newSlice.append('path')
      .attr('class', 'main-arc')
      .style('fill', d => color((d.children ? d : d.parent).data.name)) // todo
      .attr('d', arc);
  newSlice.append('path')
      .attr('class', 'hidden-arc')
      .attr('id', (_, i) => `hiddenArc${i}`)
      .attr('d', middleArcLine);
/*
.attr("display", function(d) {
        return d.depth ? null : "none";
})
*/

  const text = newSlice.append('text')
      .attr('display', d => textFits(d) ? null : 'none');
/*
  const text = newSlice.append('text')
      .attr('display', d => {
        var name = d.data.name;
        var words = name.split(' ');
        var fit = true;

        for (var i = 0; i < words.length; i++) {
          (words[i].length < 6) ? '' : (fit = false);
        }
        return fit;
      });
*/
/*
  // This shows the text
  text.append('textPath')
      .attr('startOffset','50%')
      .attr('xlink:href', (_, i) => `#hiddenArc${i}`)
      .text(d=> d.data.name);
      */
  text.append('textPath')
      .attr('startOffset','50%')
      .attr('xlink:href', (_, i) => `#hiddenArc${i}`)
      .text(d => {
        var name = d.data.name;
        var words = name.split(' ');
        return name;
       /* 
        if (words.length === 1) {
          return name;
        }
        else {
          return words[0];
          for (var i = 0; i < words.length; i++) {
         //   var tspan = text.append('tspan').text(words[i]);
            if (i > 0) {}
           //   tspan.attr('x', 0).attr('dy', '15');
          }
        }
*/
        
      });
      

  var insertLinebreaks = function (d) {
    var el = d3.select(this);
    var words = d.split(' ');
    el.text('');

    for (var i = 0; i < words.length; i++) {
        var tspan = el.append('tspan').text(words[i]);
        if (i > 0)
            tspan.attr('x', 0).attr('dy', '15');
    }
};



}
// ---------------------------------------------------------------------
// Fetch the data and show the visualisation

$.ajax({
  type: 'GET',
  contentType: 'application/json',
  url: 'http://localhost:4000/getFoodGroups',
  success: data => {
    VisualiseData(data.status)
  },
  error: (xhr, status, error) => {
    console.log(error)
  },
});

</script>
</html>